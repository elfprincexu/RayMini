#ifndef _KDMIDDLENODE_H_
#define _KDMIDDLENODE_H_

#include "kd/KdPlane.h"
#include "kd/KdData.h"
#include "kd/KdNode.h"
#include "kd/KdLeafNode.h"
#include "BoundingBox.h"
#include "Ray.h"

namespace kd {

    /*!
     *  \brief  Describes a middle node in the KD-Tree.
     *
     *  Contains child regions of an intermediary node. Children can either be
     *  other intermediary nodes or leaf node.
     */
    class KdMiddleNode
        :   public KdNode
    {

    private:
        KdNode*         m_lChild;   //!< The left child of the node, representing
                                    //!< region inferior to the cut plane's position.
        KdNode*         m_rChild;   //!< The right child of the node, representing
                                    //!< region superior to the cut plane's position.

    public:
        /*!
         *  \brief  Creates a node with no children from the list of primitives
         *          it should contain.
         *
         *  \param  iPrimitives The primitives that should be placed inside the node.
         */
        inline KdMiddleNode (
            const KdDataVector&     iPrimitives
        )   :   KdNode ()
        {
            Vec3Df minBb, maxBb;

            // Calculates bounding box's upper and lower boundaries.
            GetMinMax (
                iPrimitives,
                minBb,
                maxBb
            );

            GetRegion ().init ( minBb );
            GetRegion ().extendTo ( maxBb );

            m_lChild = (KdNode*)0x0;
            m_rChild = (KdNode*)0x0;
        }

        /*!
         *  \brief  Creates a node with no children representing
         *          a region in 3D space.
         *
         *  \param  iRegion     The region represented by the node.
         */
        inline KdMiddleNode (
            const BoundingBox&      iRegion
        )   :   KdNode ( iRegion )
        {
            m_lChild = (KdNode*)0x0;
            m_rChild = (KdNode*)0x0;
        }

        /*!
         *  \brief  Destroys the node and both of it's children.
         */
        ~KdMiddleNode ()
        {
            // If the node has a left child, delete it.
            if ( m_lChild ) {
                delete m_lChild;
                m_lChild = (KdNode*)0x0;
            }
            // If the node has a right child, delete it.
            if ( m_rChild ) {
                delete m_rChild;
                m_rChild = (KdNode*)0x0;
            }
        }

        /*!
         *  \brief  Splits an intermediary node into two child nodes.
         *
         *  Splits the bounding box of the node in half and perfotm an intersection
         *  test of every primitive against the two halves. Whenever an intersection
         *  is found, place
         *
         *  \param  iDepth      The depth of the node being split.
         *  \param  iSplitPlane The axis along which to split the node's bounding box.
         *  \param  iData       The data to be placed on child nodes.
         *  \return The maximum depth of the tree generated by the split operation.
         */
        int Split (
            const unsigned int&     iDepth,
            const KdPlane&          iSplitPlane,
            const KdDataVector&     iData
        );

        /*!
         *  \brief  Tests if a ray intersects a primitive in any of the child nodes.
         *
         *  Tests intersection against both child trees and returns that which has
         *  the smallest distance. If the ray intersects a primitive in only one of the
         *  child trees, return that intersection.
         *
         *  \param  iRay            The ray to be tested.
         *  \param  oIntersection   Where to place the intersection descriptor.
         *  \param  iNear           The minimum distance an intersection can occur.
         *  \param  iFar            The maximum distance an intersection can occur.
         *  \return true iff there is an intersection.
         */
        bool Intersect (
            const Ray&              iRay,
            KdIntersectionData&     oIntersection,
            const float&            iNear,
            const float&            iFar
        ) const;

        /*!
         *  \brief  Tests if a ray intersects a surfel in any of the child nodes.
         *
         *  Tests intersection against both child trees and returns that which has
         *  the smallest distance. If the ray intersects a surfel in only one of the
         *  child trees, return that intersection.
         *
         *  \param  iRay            The ray to be tested.
         *  \param  oIntersection   Where to place the intersection descriptor.
         *  \param  iNear           The minimum distance an intersection can occur.
         *  \param  iFar            The maximum distance an intersection can occur.
         *  \return true iff there is an intersection.
         */
        bool IntersectSurfel (
            const Ray&              iRay,
            KdIntersectionData&     oIntersection,
            const float&            iNear,
            const float&            iFar
        ) const;

    };

}

#endif // _KDMIDDLENODE_H_
